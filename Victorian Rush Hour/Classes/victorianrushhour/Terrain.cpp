#include "Terrain.h"//how many building we will have in a row between gapsint patterns[] = {1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3};//width height of each new building * by tile size//0 means that there is no change in height from previous buildingint widths[] = {2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4};int heights[] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,3,3,3,3,3,3,4};//this will not be shuffled it will be looped throughint types[] = {1,2,3,4,1,3,2,4,3,2,1,4,2,3,1,4,2,3,1,2,3,2,3,4,1,2,4,3,1,3,1,4,2,4,2,1,2,3};vector<int> _blockPattern (patterns, patterns + sizeof(patterns) / sizeof(int));vector<int> _blockWidths (widths, widths + sizeof(widths) / sizeof(int));vector<int> _blockHeights (heights, heights + sizeof(heights) / sizeof(int));vector<int> _blockTypes (types, types + sizeof(types) / sizeof(int));Terrain::~Terrain (){		CC_SAFE_RELEASE(_blockPool);	CC_SAFE_RELEASE(_blocks);}Terrain::Terrain():_screenSize(CCDirector::sharedDirector()->getWinSize()),_startTerrain(false),_blockPoolIndex(0),_currentPatternCnt(1),_currentPatternIndex(0),_currentTypeIndex(0),_currentWidthIndex(0),_currentHeightIndex(0),_showGap(false){    }Terrain * Terrain::create(){    Terrain * terrain = new Terrain();	if (terrain && terrain->initWithFile("blank.png"))    {        terrain->setAnchorPoint(ccp(0,0));        terrain->initTerrain();		terrain->autorelease();		return terrain;	}	CC_SAFE_DELETE(terrain);	return NULL;}void Terrain::initTerrain (){    _increaseGapInterval = 5000;    _increaseGapTimer = 0;    _gapSize = 2;            _blockPool = CCArray::createWithCapacity(20);    _blockPool->retain();        //init object pool    Block* block;        for(int i = 0; i<20; i++)    {        block = Block::create();        this->addChild(block);        _blockPool->addObject(block);            }        _blocks = CCArray::createWithCapacity(20);    _blocks->retain();        _minTerrainWidth = _screenSize.width * 1.5f;        random_shuffle(_blockPattern.begin(), _blockPattern.end());    random_shuffle(_blockWidths.begin(), _blockWidths.end());    random_shuffle(_blockHeights.begin(), _blockHeights.end());        this->addBlocks(0);}void Terrain::checkCollision (Player * player){	} void Terrain::move (float xMove){    }void Terrain::reset() {    }void Terrain::addBlocks(int currentWidth){    Block* block;        while(currentWidth < _minTerrainWidth)    {        block = (Block* )_blockPool->objectAtIndex(_blockPoolIndex);        _blockPoolIndex++;                if(_blockPoolIndex == _blockPool->count())        {            _blocks->addObject(block);        }    }        this->distributeBlocks();	}void Terrain::distributeBlocks(){    int count = _blocks->count();        Block* block;    Block* prev_block;        for(int i=0; i< count; i++)    {        block = (Block* ) _blocks->objectAtIndex(i);                if(i!= 0)        {            prev_block = (Block*) _blocks->objectAtIndex(i-1);            block->setPositionX(prev_block->getPositionX() + prev_block->getWidth());        }        else        {            block->setPositionX(0);        }    }	}void Terrain::initBlock(Block * block){    int blockWidth;    int blockHeight;	    int type = _blockTypes[_currentTypeIndex];    _currentTypeIndex++;        if (_currentTypeIndex== _blockTypes.size())        _currentTypeIndex = 0;	    //once player taps startTerrain is set to true    if(_startTerrain)    {        if(_showGap)        {            int gap = rand() % _gapSize;            if(gap < 2) gap =2;                        block->setupBlock(gap, 0, kBlockGap);                        _showGap = false;        }        else        {            blockWidth = _blockWidths[_currentWidthIndex];            _currentWidthIndex++;                        if(_currentWidthIndex == _blockWidths.size())            {                random_shuffle(_blockWidths.begin(), _blockWidths.end());                _currentWidthIndex = 0;            }                        if(_blockHeights[_currentHeightIndex] != 0)            {                //change height if next block                blockHeight = _blockHeights[_currentHeightIndex];                                //if diff is too high decrease it                if(blockHeight - _lastBlockHeight > 2 && _gapSize == 2)                {                    blockHeight = 1;                }            }            else            {                blockHeight = _lastBlockHeight;            }            _currentHeightIndex++;                        if(_currentHeightIndex == _blockHeights.size())            {                _currentHeightIndex = 0;                                random_shuffle(_blockHeights.begin(), _blockHeights.end());            }                        block->setupBlock(blockWidth, blockHeight, type);            _lastBlockHeight = blockHeight;            _lastBlockWidth = blockWidth;                        //select next block series pattern            _currentPatternCnt++;            if(_currentPatternCnt > _blockPattern[_currentPatternIndex])            {                _showGap = true;                                //start new pattern                _currentPatternIndex++;                                if(_currentPatternIndex == _blockPattern.size())                {                    random_shuffle(_blockPattern.begin(), _blockPattern.end());                    _currentPatternIndex = 0;                                }                    _currentPatternCnt = 1;                            }                }                }        //terrain is not being changed yet    else    {        _lastBlockHeight = 2;        _lastBlockWidth = rand() %2 + 2;        block->setupBlock(_lastBlockWidth, _lastBlockHeight, type);        }    }